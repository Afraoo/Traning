

### Java核心技术卷1

> 用来记录学习此书时的笔记和感想



##### 第一章  Java程序设计概述

主要讲述了Java语言的特性（安全），其中映像最深的是“解释型”，也就是平常所说的可移植性的原因：只要在由解释器的电脑上，都可以运行`.class`文件，该文件是通过`.java`文件编译生成的，由字节码构成。其次是关于Java的发展历程以及关于版本的说明。

##### 第二 章  Java程序设计环境

- `jdk`安装与环境变量配置

- 使用命令行中的`javac `来编译`Welcome.java`文件从而生成`Welcome.class`文件，再使用`java` 来运行`.class`文件，从而在控制台中输出程序的运行结果`Welcome to Java!`。

  > .class文件也就是字节码文件，该类文件可以在任何具有解释器的设备上运行。（可移植性）

- 使用集成开发环境来进行java开发（个人感觉VScode更灵活，插件很多很方便，IDEA更强大好用，都比Eclipse好）

- 写了一个图形化界面显示图片的小程序（感觉跟Android客户端开发部分内容有点像比如Activity中的按钮等的添加和相应事件）：

  ```java
  /**
   * This is a test.
   * @author Xilei Lin
   */
  package ImageView;
  
  import javax.swing.*;
  import java.awt.*;
  import java.io.File;
  
  public class ImageViewer {
  
      public static void main(String[] args){
  
          EventQueue.invokeLater(() -> {
              JFrame frame = new ImageViewerFrame();
              frame.setTitle("ImageViewer");
              frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
              frame.setVisible(true);
          });
      }
  }
  
  class ImageViewerFrame extends JFrame{
  
      private JLabel label;
      private JFileChooser chooser;
      private static final int DEFAULT_WIDTH=300;
      private static final int DEFAULT_HEIGHT=400;
  
      public ImageViewerFrame(){
  
          setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
  
          label = new JLabel();
          add(label);
  
          chooser = new JFileChooser();
          chooser.setCurrentDirectory(new File("."));
  
          JMenuBar menuBar = new JMenuBar();
          setJMenuBar(menuBar);
  
          //在菜单栏中添加File菜单
          JMenu menu = new JMenu("File");
          menuBar.add(menu);
          
          //将Open选项加入File菜单中
          JMenuItem openItem = new JMenuItem("Open");
          menu.add(openItem);
          openItem.addActionListener(event -> {
  
              int result = chooser.showOpenDialog(null);
              if(result == JFileChooser.APPROVE_OPTION){
  
                  String name = chooser.getSelectedFile().getPath();
                  label.setIcon(new ImageIcon(name));
              }
          });
  
           //将Exit选项加入File菜单中
          JMenuItem exitItem = new JMenuItem("Exit");
          menu.add(exitItem);
          exitItem.addActionListener(event -> {System.exit(0);});
    }
  }
  
  ```

         在该程序中，需要注意的是`Item.addActionLisener()`这个方法，该方法对针对于 *item* 的点击动作进行监听，当监听到该操作时，则执行括号中的处理。
        
         其次，关于在Java中的三种注释方式：

  - //
  - /*   ...... */
  - /**  ...... */     该种方式常用于对某个代码块进行说明，比如作者等信息也可以在其中进行声明。

- 关于applet的使用与说明。由于之前曾出现过的安全问题，导致现在的applet使用的情况并不是特别理想。



##### 第三章 Java的基本程序设计结构

1. Java程序简介

   - 类就是代码容器，是代码存放的单位，库都是由类组成的

   - Java的类名必须以字母开头，区分大小写

   - 必须有一个类的类名与文件名一致，该类的访问修饰符必须为public。其中必须包含程序入口main方法，为了能够正常执行该程序，该方法的修饰符必须为public

     

2. Java的8种基本数据（4整型，2浮点，1字符，1布尔）：

   - ` int   short   long   byte `

   - ` float   double `

   - `char`

   - ` boolean`

     > `boolean` 的值只有两个：`false（1）`，`true（0）`，与C++正好相反

     

3. 数值计算机中不允许有任何舍入误差时，使用`BigDecimal`类

   > 该类在`Package java.math`中，同在的还有`BigInteger`类

   在`BigInteger (Bigdecimal)`类中，加减乘除运算通过调用以下方法实现：

   - `a.multiply(b)`： `a * b`

   - `a.divide(b)`：`a/b`

   - `a.add(b)`：`a + b`

   - `a.subtract(b)`：`a - b`

   - `a.mod(b)`：`a % b`，取余

     当然，也可以使用`BigInteger.valueOf(a)`来讲a转换成为`BigInteger`。

   

4. `const `和 `goto `都是作为Java中的保留关键字，并不使用。

   - `strictfp`关键字是用来修饰方法的，表明在该方法中使用严格的浮点计算来得到相关结果。

   

5. 声明一个变量之后，一定要对其进行显式的初始化。比如：

   ```java
   int age = 22;
   ```

   

6. 使用`final`来修饰常量，修饰变量的话则表明该变量只能被赋值一次。

7. 使用static final来修饰类常量，这样类中的所有方法都可以使用该常量。例如：

   ```java
   public static final int age = 22;	
   ```

8. 浮点数除以0，结果无穷大（Infinity）；整数除以0，则会报以下错误：

   ```java
   java.lang.ArithmeticException
   ```

9. Math中的相关方法：

   ```java
   import static java.lang.Math.*;//注意是static
   ```

   - `sqrt(double x)`： 得到平方根,返回值是double类型

   - `pow(double x, double a)`：得到x 的a次方，返回值是double类型

   - `floorDiv(int x, int y)`

     - 当`x`和`y`符号相同时，则该方法返回的结果与`x/y`相同
     - 当符号不同时，则该方法得到的结果为：对`x`除以`y`的商向下取整

   - `floorMod(x, y)`：该方法得到结果与`floorDiv(int x, int y)`有以下关系：

     ==`floorMod(x, y) + floorDiv(int x, int y) * y = x `==

   - `atan`: 即`arctan`，得到结果范围为 `-pi/2 ~ pi/2`

   - `atan2(x,y)`：将矩形坐标`(x, y)`转化为对应的极坐标`(r, theta)`中的角度`theta`，范围为`-pi ~ pi`

   - `random()`：返回一个0~1之间（含0不含1）的随机浮点数

     

10. 数值转换：

    - 优先级：`double > float > long > int`

    - 强制转换示例 :

      > *注意：*double进行强制转换为int，通过将小数部分截掉得到。

      ```java
      double x = 99.9;
      int y = (int) x;
      ```

      

11. 关于位与boolean运算符：

    - `a && b`：当第一个表达式a为false时，第二个表达式b就不用计算了，结果为：false

    - `a || b`：当第一个表达式a为true时，第二个表达式b不用计算了，结果为：true

    - 关于三元运算符`condition ? expression1 : expression2`

      当condition为真时，结果为`expression1`中的值，否则为`expression2`中的值。

    - `>>>`用0填充高位，`>>`用符号填充高位

    - `+=`和`-=`为右结合运算符，因此：

      ```java
      a += b += c;
      a += (b += c);//优先级顺序
      ```

      

      

12. 字符串

    > 预定义类String，任何一个Java对象都可以转换成字符串

    - `subString(a, b)`：从大字符串中得到一个子串，子串范围：`a <= str <b`

    - `join(分隔符，字符串)`： 将多个字符串用分隔符分开，其中，多个字符串之间使用逗号隔开

    - 检查字符串既不是空串（使用equals()）也不是null时，要先检查null，因为在null上调用方法会报错。

      

13. Scanner

    > 这个部分需要多去写一些代码来进行练习、体会，Scanner中的next开头的方法，以及关于控制台输入的字符是否合法的判断，都需要自己多去通过代码摸索练习。

           通过以下语句来将标准输入流`System.in`与`Scanner`对象进行关联，从而可以获得控制台的输入数据。

    ```java
    Scanner in = new Scanner(System.in);
    ```

    - `printf("%8.2f",x)`：以8个字符的宽度、保留两位小数的格式输出`x`(s字符串、f浮点数、d整型)

    - *文件名包含路径时，要多加一个反斜杠*

      

14. 关`switch`的`case`标签，它可以是：

    - char、byte、short、int

    - 枚举常量（大写字母）

    - 字符串字面量（SE 7开始），例如：

      ```
      switch(str.toLowerCase()){
          case "yes":
      }
      ```

      

15. 数组中使用到的`Arrays`类（*注意：后面有个 s*）

    - `Arrays.toString(a)`：当a为一维数组时，此句将该数组元素放在中括号中输出，当a为二维数组时，则以行为单位输出，每行的数据使用中括号括起来。

    

    

    ##### 总结

    ​       在这三章中，虽是关于Java的基础知识，但是仍然很重要。特别是关于Scanner和String的一些知识讲解，这两个类对于以后的编程来讲会经常用到。因此 ，需要下来多练习这两个类其他方法的使用以及在使用时需要注意的地方。

    ​       很多书面上的知识还是需要自己去使用代码来实现练习，才能理解得更加深刻和到位。特别还需要注意一点的时，在编程的时候永远不要忘了边界条件等，书上的示例只是简单地展示并没有过多的去注意这方面。但是这些问题是一直存在且需要处理的，没有提及并不代表就不做相关处理或是不重要。最开始自己也忘了去考虑这些，直到练习到后面渐渐发现。最后，开发文档真的很好用，讲的很详细，需长期使用：https://docs.oracle.com/javase/8/docs/api/allclasses-noframe.html







##### 第四章 对象与类

> 对象都存储在堆中

1. 对象的三种特性，其中

   - 对象的行为通过方法来体现

   - 对象的状态通过实例域来体现

   - 对象变量是引用了一个对象

      ​        好的封装，应该只通过对象的方法来进行交互；而对象状态的改变必须是通过调用方法来实    现。当一个文件中有多个类时，除了和文件名相同的public公有类之外，其他非公有类中的实例域都应该是除了自身的方法可以访问外，其他类的方法都是不可读写的。但是可以提供方法来操作该类的对象以及存取它们的实例域。

   - `Accessor Method`：访问器方法，如getter

   - `Mutator Method`：更改器方法，如setter和Raise Salary方法。

     > 不是所有的域中的数据都需要设置更改器方法

   

2. 关于`LocalDate`

   > 输出的格式为：年-月-日

   - `now()`：获得当前的年月日

   - `of(1993,1,1)`：将括号中的数值构造为一个`LocalDate`对象

   - `getMnoth()`：使用该方法时得到的时月份的英文单词，若要获得具体数值，则应使用`getMonthValue()`，需要注意

   - `plusDay(int num)`：在当前日期上加上（`num`为负数时则是减去）括号中天数后的日期

   - `DayOfWeek`：该类是代表一周七天的枚举类型,使用`getValue()`可以得到某一天对应的编号，1代表周一，7代表周日。使用示例：

     ```java
     LocalDate localDate = LocalDate.now();
     DayOfWeek dayOfWeek = localDate.getDayOfWeek();
     ```

     

3. 类的访问权限

   - 一个类的方法可以访问这个类任意对象的私有域

   - public、protected、private

     

4. 隐式参数

   使用关键字`this`来表示。下例中`number007`为一个隐式的参数，5为显式参数。

   ```java
   number007.raiseSalary(5);
   ```

   

5. 构造器

   构造器与类同名，使用`new`操作符构造类的对象时，构造器会运行。需要注意的是，在类加载运行的时候，初始化的顺序如下：

   静态域、块   >  非静态域、块   >    构造函数

   > 不能在构造器中定义与实例域重名的局部变量

6. ###### 对象构造

   构造对象很重要，其中有以下几种方法可以编写构造器：

   + 重载

     多个方法中，如果名字相同，但是参数的类型与数量不同，则产生了重载。但是仅仅方法的返回类型不同则不属于重载，因为返回类型不在方法签名中。

   + 域没有显式赋值则会默认设置（0，false或null），但是方法中的局部变量必须明确初始化。

   + 在一个构造器中可以使用this来调用另一个构造器

   + 对象初始化块和静态初始化块，都在域定义之后进行。

   + 在C++中人工回收资源使用的是显式的析构器，而在Java中使用的是finalize()方法。

   ###### 总结

   ​        在本小节中主要讲的是构造器的几种编写方法，其中最常用也是最重要的就是重载，在继承父类的子类中，也经常会为了扩展父类的方法对其进行重载。当一个类中存在不止一个构造器时，可以在构在其中使用this来调用另一个构造器。关于数据域，若没有显示初始化则会默认将域初始化为默认值（数值为0，布尔为false和对象为null），String类型的数据也是String类的对象，所以在此情况下字符串也会默认初始化为null。

   ​        编写代码的时候，无论方法名还是参数名，应该尽量为提高代码的可读性而设置，代码块的逻辑与层次也要分明。

   

7. 包

   + 每个包中都是一个独立的类集合，通过包可以确保类的唯一性。
   + 当两个包中有相同名字的类（如Date）时，如果只使用其中一个包中的类时，在import时写出完整的包+类名即可；如果两个类都用，则在程序中每个类前写出具体的包名。
   + public修饰的类，可以被任意类使用。未加任何修饰符时，则可以被其所在包的所有方法访问。

   总结

   ​        进行项目开发时，应当明确每个类所在的包，以及每个类、方法和域中数据的访问权限。通过包来对代码进行管理，并且要确保每个类在正确的包中，以免虚拟机找不到类报错。

   

8. 类路径

   ​        在配置`JDK`环境的时候`classpath`的作用是为了设置虚拟机搜寻类的起始点，以及编译器进行编译的时候搜寻导入和引用的类，从而正确编译文件。

   

9. 文档注释

   ​        通过`javadoc`工具生成，在第二章中提到的三种注释方法的第三种`/**`开头`*/`结尾的注释即是文档注释。类与方法的文档注释应该分别在import之后类定义之前、方法之前。

   ​        包注释，则是在包目录中添加一个以`package.html`或者`package-info.java`命名的文件。`html`中的<body></body>中的内容会被抽取出来；而`.java`中，需要在包语句之后跟随一个文档注释。

10. 类的设计
   + 数据私有化
   + 一定要记得初始化数据
   + 不要使用过多的基本数据，可以使用类来代替
   + 优先使用不可变的类
   + 类名和方法名要能体现其作用
   + 复杂的类可以拆解为几个简单的类



##### 第五章 继承

5.1 类、超类和子类

1. Object类为标准的根类，是其他所有类的父类。因此每当创建一个类时，总是在继承。

2. 子类继承父类使用关键字`extends`来表示：

   - 子类继承父类中除了`private`访问修饰符修饰的方法和域，子类不能访问父类中的私有域，也不能删除继承的任何域和方法。
   - 在继承父类的同时，子类可以对父类进行扩展。当两个类中都有相同的方法时，为了明确调用的是父类的还是子类的方法时，可以使用关键字`super`来调用父类的方法。
   - 在子类构造器中使用`super`调用父类构造器的语句，必须是子类构造器中的第一条语句。
   - 每个类只能有一个超类

3. 多态

   - 对象变量，既可以引用父类的对象，也可以引用子类的对象，这种现象被称为多态，运行的时候能够自动选择调用哪个方法的现象称之为动态绑定。

   - 超类都可以由子类置换即子类的对象都是超类的对象，但是反过来父类转换成子类的对象时，需要对其使用`instanceof`对要转换的对象进行判断，再进行强制转换。

     ```java
     if(staff[1] instanceof Manager)
         boss = (Manager) staff[1];
     ```

     

4. 方法调用

   - 首先看调用方法的对象的类型以及方法的名字。先查找对象所在的类，再查找该类所属的父类中有没有这个方法。
   - 其次，当找到多个名字一样的方法时，根据调用的方法中的参数类型来确定到底是哪一个方法。
   - 然后要确定该方法是静态绑定的还是动态绑定的。静态绑定的方法编译器可以明确地知道该调用哪一个。
   - 最后，动态绑定的方法，要查找与对象调用的方法实际类型最合适的类中的方法进行运行。

5. 关键字final

   - 修饰类时，表示这个类不允许继承扩展，类中的方法（不包括域）也不允许覆盖。
   - `private`修饰的方法都是final

6. 抽象类（重构工具）

   ​       超类更像是一个为子类提供通用接口的抽象基类，但是超类中的很多方法并没用实现，因此为超类创建对象是没有什么意义的。为了避免没有意义的对象创建，并能够在编译时期就能发现这个问题，Java提供了抽象类和抽象方法机制。

   - 类中有至少一个抽象方法的类必须被声明为抽象类
   - 抽象类中可以有具体的数据和方法
   - 抽象类可以不含抽象方法
   - 抽象类不能够被实例化。抽象类的对象变量都是引用的非抽象子类对象

7. protected：对本包和所有子类可见

小结：

通过继承，可以将某个类的功能扩展得更为完备而不怎么需要去修改原本的父类，这和重载有异曲同工之处，使得代码的封装行得到很好地保证。但同时，对于父类的设计也就增加了一定的难度，需要好好思考关于父类的方法和域的划分和定义。关于抽象类，对该类的对象进行初始化的时候，需要使用非抽象的子类来进行，它的对象变量并不能够引用该类的对象。

5.2 所有类的超类——Object

1. `equals()`方法：检测两个对象是否相等，是否指向同一块存储区域（相同的引用）
   - `getClass()`：返回对象所属的类，两个对象属于同一个类的时候才有可能相等。限制在同一个类中的对象进行比较。
   - ` a instanceof b`：判断a属于b类还是b的子类。
   - `Object.equals(a,b)`：a和b全为null时返回true，其中一个为null时返回false。当a、b都不为null时，应该用`a.eauals(b)`来进行判断。
   - 无论集合如何实现，都因该由将两个集合进行比较的功能。
   - `==`：对基本数据进行比较
2. `hashCode()`：返回对象的散列码（整型，可为负数）。
   - `hashcode() `与 `equals()`的定义必须一致
   - 数组使用`Arrays.hashCode()`来计算散列码
3. `toString()`：对象可以调用`toString()`来获得其字符串描述，基本数据类型不仅可以使用`toString()`还可以使用`+`来实现。

小结：

由于equals()以及`toString()`方法都在根类Object中有定义，因此为了适应不同的使用条件，最好在自定义的类中覆盖这两个方法，且`hashCode()`方法需要与equals()方法保持一致性。除此之外，equals()方法不能被`null`对象调用，因此在不确定对象是否为空时，不要使用`a.eauals(b)`来进行判断。

5.3 泛型数组列表

1. `ArrayList`数组可以动态地更改数组大小的问题：当内部数组满时，会自动创建一个更大的数组并将小的数组拷贝到达数组中。
2. - `add()`：添加元素，可以根据索引值来进行添加（`add(int index, int num)`）。
   - `get()`：获取数组中的元素，同样可以根据索引值来进行操作。
   - `size()`：返回数组中元素的个数，即实际大小。
   - `remove()`：删除数组中的某个数。
   - 可以使用`toArray()`来将`ArrayList`数组拷贝到数组中（`int [] n =new[list.size()]`）。
3. 将原始化的`ArrayList`赋给一个类型化的`ArrayList`会报`warning`，使用类型转换并不能够解决问题。

小结：

与常规的整型数组不同，`ArrayList`在不确定数组大小的场合比较友好，但是与数组操作不同，`ArrayList`数组的增删查改都是通过方法进行的，需要区分开来。其次，明确泛型类之后，会方便编译器进行检查。最后，对于较小型的`ArrayList`来讲，增删查改的代价还能接受；但对于大型的数组来讲机会比较耗费资源，此时还应该考虑使用链表来进行操作。

5.4对象包装器与自动装箱

- 对于int整型：`Integer.valueOf(int n)`，反过来将Integer赋给int 时`int n=list.get(i).intValue()`
- 对于字符串String：`Integer.parseInt(String s)`。

5.5 参数数量可变的方法

最好的例子就是`printf()`，可以在其中接收多个参数。在Java中，省略号`...`表示这个方法可以接收任意个数量的对象。

5.6 枚举类

```java
public enum Size{SMALL, MEDIUM,LARGE};
```

- 该类都是`Enum`类的子类。
- 比较枚举型的值时可以直接使用`==`来进行。
- `Size.SMALL.toString()`将返回"SMALL"，该方法的逆方法是静态的：`Size s = new Enum.valueOf(Size.class,"SMALL")`。
- 静态的`values()`方法，返回包含全部枚举值的数组。

5.7 反射库

1. 反射：能够分析类能力的程序。

   - 运行时分析类
   - 运行时查看对象
   - 通用数组操作代码
   - 使用Method 对象

2. Class类

   - 通过`Object`中的`getClass()`方法获得一个`Class`类的实例
   - 通过`forName(className)`来获得类名对应的`Class`对象（使用时提供异常处理）
   - `T.class`代表匹配的类对象，其中T时任意的Java类型，包括void关键字
   - 通过`getName()`获得调用这个方法的对象所属类的名字
   - 一个完整的类在包中时，将包名也作为类名的一部分
   - `e.getClass().newInstance()`：调用默认的构造器来动态地创建一个与e相同类的新实例，因此当默认构造器不存在时，会抛出异常。

3. 异常捕获

   ```java
   try{
   
   }catch(e){
   
   }finally
   ```

   上面的语句块常被用于异常的捕获和处理。需要注意的是，无论有无异常发生，finally中的语句都必定被执行。

4. 利用反射检查类的结构（`java.lang.reflect`）

   Field、Method和Constructor三个类中：

   - 都有`String getName()`的方法，返回域、方法或是构造器的名字
   - 都有`int getModifiers()`方法，返回域、方法或是构造器的修饰符的整型数值。结合`Modifier`类中的方法可以针对返回的整型数值进行分析，从而可以得到对应的修饰符到底是哪一个。
   - Field类有一个`getType()`的方法，返回描述域所属类型的Class对象。
   - Method类中有一个`invoke()`方法，它的参数和返回值都是Object类型，可以调用包装在当前Method对象中的方法。
   - 可以通过Field中的`get()`方法来查看可访问的对象域，但若对象域是私有的，就应该先使用`setAccessible(true)`来得到访问的权限。
   - 一个对象数组不能转换成其他数组。通过`java.lang.reflect`中`Array`的`newInstance()`来创建一个确定类型和长度的数组，其中`CopyOf()`方法可以用于扩展任意类型的数组。

   

##### 第六章 接口、`Lambda`表达式与内部类（8月14日）

6.1&6.2 接口及接口示例

1. 接口：不是类，是对类的一组需求    *超类中的方法‘对于子类来讲就是提供了一个通用接口*

   + 接口中的方法都是`public`
   + 不能有实例域或静态方法，但是可以有常量，且被自动声明为`public static final`
   + 不能使用`new`来构造接口的对象，可以声明接口变量，但是该变量必须引用实现了该接口的类的对象，使用`instance`来检查对象是否实现了接口
   + 可以被扩展，使用关键字`extends`。    
   + 可以在接口中实现方法
   + 可以有静态方法，也可以提供一个默认实现，使用`default`关键字来进行。
     + 默认方法可以调用任何其他方法
   + 

2. 解决默认方法冲突

   > 前提：一个接口中有默认方法，在超类和另一个接口中定义了同样的方法

   + 超类优先：如果超类提供了一个具体的实现方法，则默认方法会被忽略

     

   + 接口冲突(一个超接口有默认方法，另一个接口提供了一个相同的方法)

     + 一个类同时实现了两个接口：

       必须在类中重新覆盖该方法，并指明覆盖的是哪一个

     + 一个类扩展了超类并实现了一个接口，并从超类和接口继承了相同的方法：

       只会考虑超类的方法，接口的哪怕是默认方法也会被忽略（类优先）

       

3. 类来实现接口

   - 类实现接口使用关键字`implements`来进行，且由该类提供接口对应的实例域和方法(必须声明为`public`)实现
   - 每个类只能有一个超类，却可以实现多个接口，接口之间使用逗号隔开。
   - 抽象类只能扩展于一个类

4. 克隆

   + 浅克隆：实现`Cloneable`接口后，调用`clone()`方法来进行，这样的方式得到的克隆对象并不能够访问原来该对象引用的其他对象
   + 深克隆：实现`Cloneable`接口后，并重新定义`clone()`方法将其指定为`public`。这样的方式得到的克隆对象能够访问原来该对象引用的其他对象。

   小结：

   ​       接口为类进行不同的操作提供了方法入口，但是需要使用这些入口的类自己对其进行实现。常用到的就是`Runable`接口，每次`implements`该接口后都要求必须`override`该接口的`run()`方法。并且在一个类既有继承又有实现接口的时候，`extends`关键字要放在`implements`关键字之前。克隆提供了一个复制对象及其子对象后再进行的操作不会影响到原对象的方法，但是在使用的时候要记得实现接口`Cloneable`。

6.3 lambda 表达式

```java
(String first, String second) -> first.length() - second.length()
```



1. `lambda`表达式是一个可以在以后执行一次或多次的可传递代码块。

2. 语法：

   + 组成：参数以及类型，箭头，表达式
   + 必须传入变量规范，没有参数则使用空括号代替。
   + 如果表达式无法放置需要完成的计算，则将之放入`{}`中。
   + 返回类型不需要指定，表达式可以通过上下文推导出来；要返回值时，所有分支都应有返回值

3. 函数式接口 & 方法引用

   + `lambda`表达式可以转换成接口，因此不能把其赋给Object类型的变量，因为Object不是一个函数式接口

   + 方法引用使用`::`操作符来分隔方法名和对象或类名

     ```java
     x -> System.out::println(x)//相当于System.out.println(x);
     ```

   + 

4. 变量作用域

   + 在`lambda`表达式中，只能引用值不会改变的变量
   + 当`lambda`表达式捕获外围作用域的变量在表达式中可改变或是在外围作用域改变，则是违法的
   + 不能再表达式中声明一个与局部变量同名的参数或局部变量。
   + 在表达式中使用关键字`this`时，引用的时使用该表达式的方法的`this`参数。

   小结：

   ​       `lambda`表达式可以传递到对象中多次被调用，因此可以用于并发场景以及监听广播等场景。在第二章中的图形化界面的例子中，就使用了一个表达式放在`item`的监听方法中，以便在点击这个`item`的时候可以执行该表达式。但是就今天的学习结果来看，需要下来做一些相关练习才能加深理解与印象。

6.4 内部类

1. 内部类是定义在另一个类中的类
   + 可以访问自身的数据域，也可以访问创建它的外围类的数据域，包括私有域。原因是因为内部类的对象总有一个隐式引用是指向创建它的外部类的对象的。
   + 可以对同一个包中的其他类隐藏，可以是私有类
   + 定义一个回调函数且不编写大量代码时，可以使用匿名内部类
   + 在内部类不需要访问外围对象的时候，应该使用静态内部类，静态内部类可以有静态域和方法。
   
2. 语法规则
   
   + 外围类引用`OuterClass.this`
   
   + 内部类对象的构造器：
   
     ```java
     ActionListener listener = this.new TimePrinter();
     ```
   
   + 内部类中声明的所有静态域都必须是`final`
   
   + 内部类中不能有静态方法
   
3. 局部内部类

   + 方法中定义局部类
   + 不能用public 或者 private进行声明
   + 可以访问外部定义为`final`的局部变量

4. 匿名内部类

   + 匿名类没有类名，因此没有构造器。将构造器参数传递给超类构造器

     ```java
     new SuperType(){//也可以是接口：Interface()
        inner class methods and data
     };
     ```

   + 双括号初始化：

     ```
     invite(new ArrayList<String>() {{add("Harry"); add("Tony");}});
     ```

     外层括号建立了一个`ArrayList`的匿名子类，内层括号则是一个对象构造块。

   小结：

   ​      在实现事件监听器和其他回调的时候可以使用匿名内部来进行，但是此时也可以使用`lambda`表达式，个人觉得就易读性而言，`lambda`表达式更直观易懂一些。

6.5 代理

1. 在程序运行过程中创建一个实现了一组给定接口的新类。

   + 代理类具有指定接口中所需的和`Object`类中的全部方法，但定义这些方法的需要使用调用处理器来进行（如下）。

     ```java
     object invoke(Object proxy, Method method, Object[] args)
     ```

     每当代理对象的方法被调用时，都会向调用处理器传递`Method`对象和原始的调用参数，调用处理器的`invoke()`方法都会被调用，而调用处理器定义在`Proxy`超类中。

2. 创建代理对象

   + 所有的代理类都扩展于`Proxy`类，因此在创建代理对象的时候使用`Proxy`类的`newProxyInstance()`方法。

     ```java
     static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler handler)
     ```

     其中`null`代表使用默认的类加载器，`Class`对象数组中是需要实现的接口，最后是一个调用处理器。

   + 对于特定的类家加载器和一组预设的接口来讲，只能有一个代理类。

   + 代理类一定是`public`和`final`。此时可以使用`Proxy`超类中`inProxyClass()`方法来检测该Class对象是否是一个代理类。





##### 第七章 异常、断言和日志

7.1 处理错误

1. 在遇到错误是，正确的处理方式：

   - 返回安全状态，能够让用户执行一些操作
   - 允许用户保存所有操作结果

2. 可能会出现的错误类型：

   + 用户输入错误：输入了程序期望之外的值
   + 设备错误：设备没有响应或是暂时不能工作
   + 物理限制：磁盘满了
   + 代码错误：程序无法正常运行

3. 方法中错误的处理方法

   + 方法中的错误返回一个错误码，再调用方法进行分析。通常适用于文件读取信息的方法，或者对象的null引用。
   + 方法抛出一个封装了错误信息的对象，且方法立即退出不返回任何值，接下来异常处理机制开始搜索对应的异常处理器。

4. Java中的三种处理错误机制：

   + 抛出异常
   + 日志
   + 使用断言

5. 异常分类

   + 超类`Throwable`：分为子类`Error`和`Exception`；而`Exception`又分为`RuntimeException`和`IOException`

     + `Error`： 运行时系统内部错误和资源耗尽错误
     + `RuntimeException`：程序错误导致的异常
     + `IOException`：类似I/O错误问题导致的异常

   + 非受查异常：`Error`和`RuntimeException`

   + 受查异常：其他所有异常

     + 方法要在首部声明所有可能抛出的异常。受查异常都要声明，而非受查异常不需要声明。

       

6. 子类方法抛出的异常应该比超类的方法抛出的异常更特定、具体。

7. 对于已经存在的异常类，抛出该类异常时，首先找到这个异常类，然后创建这个类的一个对象，最后将对象抛出。

小结：

所有的非受查异常都应该尽量避免它们的产生，而对于受查异常则应具备完善的处理它们的方法或者过程。如果要自己创建异常类，则应记得将该类异常继承的类别声明清楚。写代码的时候尤其要注意关于空指针的引用和数组下标越界，好的代码应该又尽量少的缺口。

7.2 捕获异常

1. 调用抛出受查异常的方法，要么对这个异常进行处理，要么继续传递（方法首部加`throw`说明符）

2. 设置`try/catch/finally`语句块

   + `try`中时可能会抛出异常的代码块，`catch`中则是对`try`中抛出的异常的的处理器代码。但如果`try`中没有抛出异常，则会直接跳过`catch`中的代码。
   + 无论有无异常抛出，`finally`中的语句都最终会被执行。因为这种特性，`finally`语句中常常放置回收或者关闭资源的语句 。

3. 当捕获的异常类型之间不存在子类关系时才可以在一条`catch`中捕获多个异常

   ```java
   catch(FileNotFoundException | UnknownHostException e)
   ```

4. `catch`中也可以抛出异常（该异常则为最终抛出的异常），如果与`catch`中最初声明的类型不同的话，这相当于改变了抛出异常的类型。

5. 当使用`return`退出`try`语句块时，如果`finally`中也有`return`，则`finally`中的将会覆盖原来的返回值。

6. 带有资源的`try`语句

   ```java
   try(Resource res){...}
   ```

   + 当`try`块退出时，会自动调用`close()`方法
   + 可以指定多个资源，之间用分号隔开
   + `catch`和`fially`中的内容会在关闭资源之后执行。

小结：

异常的捕获可以根据实际情况使用不同的方式来进行，但是最终都是在`try/catch/finally`语句块这个大纲下进行，这个需要记住。对于资源使用后的关闭和释放问题，可以放在`finally`中，或者为了避免`finally`中的语句也出现异常使用带资源的`try`语句块。至于堆栈轨迹分析，则需要调用`Throwable`中的相关方法来获得信息，从而打印出来方便开发者分析。

7.3 使用异常机制的技巧

1. 只在有异常的情况下捕获异常 
2. 不过分细化异常
3. 将一种异常转换成另一种更加细致的适合的异常
4. 不要压制异常
5. 早抛出，晚捕获。传递异常比捕获好，让更高层次的方法来进行捕获。

小结：

并不是所有的异常都要在第一时间进行捕获，可以将其通过`throw`关键字传递给高层次的有能力捕获并处理该异常的方法。与之恰恰相反的是，一个方法中有受查异常一定要第一时间抛出。要在对的时机做对的事，否则就会产生问题。             

7.4 断言

1. 允许在测试期间想代码中插入检查语句，代码发布时这些语句将会被*自动*移走。

2. 使用关键字`assert`来表示断言，有两种形式如下：

   + `assert 条件`：对条件进行检测，如果结果为`false`，会抛出一个`AssertinoError`异常
   + `assert 条件:表达式`：r如果结果为`false`，则表达式会被传入`AssertinoError`，被转换成一个消息字符串

3. 默认情况下，断言是被禁用的，可以通过命令在程序运行时启用：

   ```java
   java -enableassertions 运行的类名//或者-ea
   ```

   或者禁用：

   ```java
   java -disableassertions 运行的类名//或者-da
   ```

4. 使用须知：

   + 断言失败是致命的、不可恢复的错误
   + 断言检查只用于开发和测试阶段

小结：

正确地使用断言工具可以方便开发人员对程序进行检查，且断言的使用应该限制在开发和测试阶段，使用时需谨慎。

7.5 日志

1. 基本的日志

   + 使用全局日志记录器来调用`info()`可以生成一个简单的日志
   + 使用全局日志记录器调用`setLevel(Level.OFF)`时，会取消所有的日志
   + 不要将所有的日志都放到全局日志记录器中

2. 关于日志记录器、格式化器和处理器

   - 记录器：日志使用者通过记录起来发起日志记录请求，并提供日志内容，同时指定该日志的级别

     + 创建记录器：

       ```java
       private static final Logger myLogger = Logger.getLogger("com.mycompany.myapp");
       ```

     + 7个级别，由高到低分别是：`SERVER、WARNING、INFO、CONFIG、FINE、FINER、FINEST`

     + 默认情况下只记录前三个级别

     + 日志记录器的父与子之间共享日志级别

     + 获得不可预料异常的相关日志可以通过`void throwing()`方法，该方法记录一条FINER级别的日志

       

   - 格式化器：对记录器提供的日志进行格式化，并提供某些参数（比如加上头部和尾部）

   - 处理器：把经格式化之后的日志输出到某些地方

     - 默认将日志记录发送到`ConsoleHandler`处理器（默认级别为INFO）中，并输出到`System.err`流中
     - 日志记录的级别必须高于记录器和处理器的阈值

3. 过滤器：根据日志记录的级别进行过滤

   ```java
   boolean isLoggable(LogRecord record)
   ```

   + 同一时刻，最多只能有一个过滤器

4. 日志记录说明

   + 日志记录器命名为与主应用程序包一样的名字
   + 默认将级别等于或高于INFO的所有消息记录到控制台
   + 程序员想要的日志记录最好设定为FINE级别

小结：

关于日志的方法实在是有点多，想要挨个记下来再进行使用有一定的难度。因此在以后使用日志的过程中，需要结合相关`API`文档来进行操作，避免出现错误。但与断言相比，日志最好的地方就是可以记录那些不可预料的异常，毕竟作为程序员也不能够完全预料到下一个异常会出现在哪里。除此之外，日志可以方便我们去跟踪程序整个生命周期内的一个运行情况，而不是仅仅只是一段时间内的情况。