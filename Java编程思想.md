#### Java编程思想

###### 第八章 多态

8.1向上转型

1. 子类的对象可以转换成为超类的对象。超类的接口子类中有，从子类向上转型到超类可能会缩小接口，但是并不会比超类的接口窄。向上则是因为在继承树的画法中，超类是在上方的。

   **小结**：

   ​       由于子类可以向上转型为超类，因此在创建一个子类对象的时候也就相当于同时创建了一个超类的对象。在超类存在默认的构造器时则会调用构造器，在运行的时候首先会执行类中静态域的初始化，其次是域，最后是运行构造器中的代码。

8.2 转机 

1. `Java`中`static`方法和`final`方法(`private`方法属于`final`方法)不具有多态性，且静态方法是与类关联而非与对象关联的。除了它们之外，其他所有的方法都是后期绑定的。

   小结：

   ​       对于超类来讲，子类可以对其进行扩展；对于子类来讲，无论超类新增什么方法，都不影响原来代码的正常运行，这是多态带来的方便之处。但同时多态也具有限制性，它在面对私有和静态的方法时是不可行的。

8.3构造器与多态

1. 进入子类构造器时，基类中的可供访问成员都应该已经得到初始化。为了确保所要使用的成员都已经构建完毕，于是此时的调用顺序为：

   基类静态(全局)变量初始化 >  子类静态(全局)变量初始化  > 基类变量初始化 >  基类构造器中的内容   >    子类变量初始化  >  子类构造器中的内容

2. 继承与清理：

   在超类中由垃圾回收的一部分特殊清理动作，则在子类中必须覆盖`dispose()`方法。





##### 第九章 接口

9.1 抽象和抽象类方法（已与Java核心技术中抽象类笔记合并）

1. 抽象类有以下特点：
   + 有一个或多个抽象方法的类都必须声明为抽象类
   + 抽象类可以没有抽象方法
   + 抽象类一旦被继承并创建该类的对象，则必须为超类的所有抽象方法提供方法定义，它不能被直接实例化

9.2 接口

1. 一个类可以实现多个接口，从而来达到实现多重继承的目的。
2. 在接口中的域都是`static`和`final`的，方法都是`public`的。
3. `toString()`方法是根类`Object`的一部分，因此不需要出现在接口中。
4. 提高代码的复用性

9.3 完全解耦

将接口从具体实现中解耦，可以使得接口应用于不同的具体实现，从而提高代码的复用性。

1. 策略设计模式

   + 可以创建一个能够根据所传递的参数对象的不同而具有不同行为的方法
   + 这类方法包含算法中固定不变的部分，策略包含变化的部分。策略就是传递进去的参数对象，它包含要执行某些操作的代码。

2. 适配器设计模式

   + 适配器接受拥有的接口，并产生需要的接口。

   小结：

   ​       虽然子类继承超类的方法使得超类相当于一个接口，但是超类中的方法只能在它以及其子类中可以使用，在非继承类中使用这些方法则是非法的，而接口中的方法则没有这些限制。对于不同的应用场景需要接口不同的具体实现，又可以选择适当的设计模式来进行。与类之间的继承相比，接口是面向大众的。你可以在一个类中对多个接口中的方法来进行具体实现，既扩展了该接口，又使得该类的功能更加强大与完善，能更大大提高代码的复用性。在这种复用性中，设计模式也是很重要的一环，选择恰当的设计模式能个事半功倍。

9.4 Java中的多重继承

1. 一个类可以实现多个接口，但是继承的类要放在实现的接口之前。
2. 接口能够向上转型为多个基类型，且不能够创建接口的对象。

9.5 通过继承来扩展接口

1. 接口可以继承一个或者多个接口来产生一个新的接口，而类只能继承一个超类。
2. 组合多个不同的接口时，要尽量避免不同的接口中存在相同方法名这种情况。

9.6 适配接口

让方法接受接口类型，可以使得所有实现了这个接口的类都能够使用该方法，这比让方法接受类要强大得多。

9.7 接口中的域

1. 由于接口中的域都时`static`和`final`的，因此接口常被用于创建常量组，这些常量使用大写字母风格，与枚举类型有点相似。
2. 接口中的域是默认`public`，且不能是空`final`

9.8 嵌套接口

1. 接口之间可以嵌套，嵌套在另一个接口中的接口自动是`public` ，不能是`private`
2. 实现接口时，可以不实现嵌套在其中的任何接口。
3. 类中可以有接口，`private`修饰的接口强制其中的方法定义不要添加任何类型信息，且只能在定义它的类中实现。

9.9接口与工厂

1. 工厂方法设计模式：生成遵循某个接口的对象的典型方法

   + 在工厂对象上调用创建方法，将生成接口的某个实现的对象，以此达到将代码和接口完全分离。

   



##### 第十章 内部类

10.1 创建内部类

1. 将内部类的定义放在外围类的里面
   + 在外围类中除了静态方法之外的地方创建一个内部类的对象时，需要具体指明这个对象的类型：`OuterClass.InnerClass`

10.2 链接到外部类

1. 内部类对象只能在与其外部类的对象相关联的情况下才能被创建。
2. 在内部类是非静态类时，构建内部类对象需要一个指向其外围类对象的引用。
3. 内部类拥有其外围类的所有元素的访问权，这是因为当外围类对象创建一个内部类的对象时，内部类的对象会有一个隐式的指向这个外围类对象的引用。

10.3 `.this`和`.new`

1. 使用外部类名字加上`.this`和`.new`，可以生成一个对外部类对象的引用，并且该引用自动具有正确的类型。

   + 使用`this`创建外部类对象：

     ```java
     public Outer getOuter(){return Outer.this;}
     ```

   + 使用`new`创建某个类的内部类对象：

     ```java
     Outer out = new Outer();
     Outer.Inner in = out.new Inner();
     ```

2. 没有外部类对象之前不可能创建内部类对象，但当创造的类是嵌套类（静态内部类）时，则该内部类不需要对外部类对象的引用。

10.4 内部类与向上转型

内部类为`private`修饰时，除了外部类没人能访问它；`protected`修饰时，除了外部类及其子类、包中的其他类之外也都不能访问。

10.5  在方法和作用域内的内部类

1. 定义在方法中的类——局部内部类
2. 定义在方法和作用域之内的内部类，在定义它的方法和作用域之外，他是不可用的。

10.6 匿名内部类

1. 当一个参数在匿名内部类中被使用时，它必须被声明为`final`
2. 匿名类中不可能有命名构造器
3. 匿名内部类既可以扩展接口也可以扩展类，但是二者不可兼得


小结：

在匿名类中，似乎能更好地去理解向上转型。在一个方法中定义一个匿名内部类，

```java
public A getClassA(){
    return new A(){....}; 
}
```

这个方法返回的是A类的对象，那么这个方法实际上就是创建了一个继承自A类的匿名类对象，并通过`new`返回的引用被自动向上转型成对A的引用。这样看来向上转型与匿名类之间的关系非常的密切，也更能帮助我们去理解向上转型。而匿名类与工厂方法的结合大大减少了冗余代码的产生，使得代码结构简洁明了。



10.7  嵌套类

不需要内部类与其外围类之间有联系，则可以将内部类声明为static，这样的内部类称之为嵌套类。

1. 不需要外围类的对象就可以创建嵌套类的对象
2. 不能从嵌套类的对象来访问非静态的外围类对象
3. 嵌套类可以有字段与方法static数据和字段
4. 接口内部的嵌套类，可以被这个接口的所有不同实现共用
5. 嵌套类放置测试代码（放置main方法）
6. 多层嵌套类中，最内部的类可以访问外围类的所有成员。

10.8 为什么要内部类

1. 抽象类或是具体的类，则内部类能实现多重继承。
2. 应用程序框架：被设计用以解决某类特定问题的一个类或一组类
   + 模板方法：编写代码定制应用程序框架中的通用解决方案来解决自己特定的问题。



